#!/bin/sh

# This file defines track - a minimalist data tracker

# Copyright (C) 2018 tomasino@sdf.org

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

#-----------------------------------------------------------------------

version="v0.0.1"

show_help () {
  cat > /dev/stdout << END
track [options] [metric] [value]

DIRECTORY:
  If the environment variable $TRACK_DIR is set, track will store
  all data in that location. Otherwise the default is the current
  working directory.

USAGE:
  track weight 150            Log 150lbs for today's weight
  track -n 10 calories        Show last 10 days calorie values
  track mood                  Show last value logged for mood

OPTIONS:
  -a                          Show all values of metric
  -n N                        Show N values of metric
  -x                          Remove metric file
  -h                          Show this help
  -v                          Show current version info
  -d                          Debug mode
END
}

TRACK_DIR=${TRACK_DIR:-.}
arg_metric=""
arg_value=""
arg_listnum=""
arg_remove=""
flag_options="hvdan:x:s"
flag_debug=0
flag_help=0
flag_listall=0
flag_listnum=0
flag_remove=0
flag_version=0
flag_shortlist=0

die () {
  msg="$1"
  code="$2"
  # exit code defaults to 1
  if printf "%s" "${code}" | grep -q '^[0-9]+$'; then
    code=1
  fi
  # output message to stdout or stderr based on code
  if [ ! -z "${msg}" ]; then
    if [ "${code}" -eq 0 ]; then
      printf "%s\\n" "${msg}"
    else
      printf "%s\\n" "${msg}" >&2
    fi
  fi
  exit "${code}"
}

parse_input () {
  if ! parsed=$(getopt ${flag_options} "$@"); then
    die "Invalid input" 2
  fi

  eval set -- "${parsed}"

  while true; do
    case "$1" in
      -h)
        flag_help=1
        shift
        ;;
      -v)
        flag_version=1
        shift
        ;;
      -d)
        flag_debug=1
        shift
        ;;
      -a)
        flag_listall=1
        shift
        ;;
      -n)
        flag_listnum=1
        shift
        arg_listnum="$1"
        shift
        ;;
      -x)
        flag_remove=1
        shift
        arg_remove="$1"
        shift
        ;;
      -s)
        flag_shortlist=1
        shift
        ;;
      --)
        shift
        break
        ;;
      *)
        die "Internal error: $1" 3
        ;;
    esac
  done

  for arg in "$@"; do
    argc=$(printf "%s" "${arg}" | tr '[:upper:]' '[:lower:]')
    if [ "${arg_metric}" = "" ]; then
      arg_metric="${argc}"
    elif [ "${arg_value}" = "" ]; then
      arg_value="${argc}"
    fi
  done
}

main () {
  parse_input "$@"

  if [ ${flag_shortlist} -gt 0 ]; then
    out=$(find "${TRACK_DIR}"/*.csv -maxdepth 1 2>/dev/null | sed -e 's/.*\///' | sed -e 's/\..*$//')
    die "${out}" 0
  fi

  if [ ${flag_version} -gt 0 ]; then
    printf "%s\\n" "${version}"
  fi

  if [ ${flag_help} -gt 0 ]; then
    show_help
  fi

  if [ ${flag_debug} -gt 0 ]; then
    set -x
  fi

  if [ ${flag_remove} -gt 0 ]; then
    rm "${TRACK_DIR}/${arg_remove}.csv"
  fi

  if [ "${arg_metric}" != "" ]; then
    f="${TRACK_DIR}/${arg_metric}.csv"

    # If new file, add header
    if [ ! -f "$f" ]; then
      printf "year,month,day,%s\n" "${arg_metric}" > "$f"
    fi

    if [ "${arg_value}" != "" ]; then
      #printf "arg_value=%s\n" "${arg_value}"
      d=$(date '+%Y,%m,%d')
      l=$(sed -n "/$d/{=;}" "$f")
      if [ -z "$l" ]; then
        printf "%s,%s\n" "$d" "${arg_value}" >> "$f"
      else
        sed -i"" "$l c $d,${arg_value}" "$f"
      fi
    else
      if [ ${flag_listall} -gt 0 ]; then
        awk -F "," 'NR>1 {printf "%s-%s-%s\t%s\t\n", $1, $2, $3, $4;}' "$f"
      elif [ ${flag_listnum} -gt 0 ]; then
        tail -n "${arg_listnum}" "$f" | awk -F "," '{printf "%s-%s-%s\t%s\t\n", $1, $2, $3, $4;}'
      else
        tail -n 1 "$f" | awk -F "," '{printf "%s-%s-%s\t%s\t\n", $1, $2, $3, $4;}'
      fi
    fi
  fi
}

main "$@"
